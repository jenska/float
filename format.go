package float

import "fmt"

// FormatFloat converts the extended floating-point number f to a string,
// according to the format fmt. It rounds the result assuming that the
// original was obtained from a floating-point value of 80 bits.
//
// The format fmt is one of
// 'b' (-ddddp±ddd, a binary exponent),
// 'e' (-d.dddde±dd, a decimal exponent),
// 'E' (-d.ddddE±dd, a decimal exponent),
// 'f' (-ddd.dddd, no exponent),
// 'g' ('e' for large exponents, 'f' otherwise),
// 'G' ('E' for large exponents, 'f' otherwise),
// 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or
// 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).
//
// The precision prec controls the number of digits (excluding the exponent)
// printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats.
// For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point.
// For 'g' and 'G' it is the maximum number of significant digits (trailing
// zeros are removed).
// The special precision -1 uses the smallest number of digits
// necessary such that ParseFloat will return f exactly.
func (a X80) Format(fmt byte, prec int) string {
	return string(genericFtoa(make([]byte, 0, max(prec+4, 24)), a, fmt, prec))
}

// AppendFloat appends the string form of the floating-point number f,
// as generated by FormatFloat, to dst and returns the extended buffer.
func (a X80) Append(dst []byte, fmt byte, prec int) []byte {
	return genericFtoa(dst, a, fmt, prec)
}

func genericFtoa(dst []byte, a X80, fmt byte, prec int) []byte {
	/*
		neg := a.sign()
		exp := a.exp()
		mant := a.frac()

		switch exp {
		case 0x7fff:
			// Inf, NaN
			var s string
			switch {
			case mant != 0:
				s = "NaN"
			case neg:
				s = "-Inf"
			default:
				s = "+Inf"
			}
			return append(dst, s...)

		case 0:
			// denormalized
			exp++

		default:
			// add implicit top bit
			mant |= uint64(1) << flt.mantbits
		}
		exp += flt.bias

		// Pick off easy binary, hex formats.
		if fmt == 'b' {
			return fmtB(dst, neg, mant, exp, flt)
		}
		if fmt == 'x' || fmt == 'X' {
			return fmtX(dst, prec, fmt, neg, mant, exp, flt)
		}

		if !optimize {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt)
		}

		var digs decimalSlice
		ok := false
		// Negative precision means "only as much as needed to be exact."
		shortest := prec < 0
		if shortest {
			// Try Grisu3 algorithm.
			f := new(extFloat)
			lower, upper := f.AssignComputeBounds(mant, exp, neg, flt)
			var buf [32]byte
			digs.d = buf[:]
			ok = f.ShortestDecimal(&digs, &lower, &upper)
			if !ok {
				return bigFtoa(dst, prec, fmt, neg, mant, exp, flt)
			}
			// Precision for shortest representation mode.
			switch fmt {
			case 'e', 'E':
				prec = max(digs.nd-1, 0)
			case 'f':
				prec = max(digs.nd-digs.dp, 0)
			case 'g', 'G':
				prec = digs.nd
			}
		} else if fmt != 'f' {
			// Fixed number of digits.
			digits := prec
			switch fmt {
			case 'e', 'E':
				digits++
			case 'g', 'G':
				if prec == 0 {
					prec = 1
				}
				digits = prec
			}
			if digits <= 15 {
				// try fast algorithm when the number of digits is reasonable.
				var buf [24]byte
				digs.d = buf[:]
				f := extFloat{mant, exp - int(flt.mantbits), neg}
				ok = f.FixedDecimal(&digs, digits)
			}
		}
		if !ok {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt)
		}
		return formatDigits(dst, shortest, neg, digs, prec, fmt)
	*/
	return nil
}

func (a X80) Internal() string {
	return fmt.Sprintf("%04X%016X", a.high, a.low)
}

func (a X80) String() string {
	return a.Internal()
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
