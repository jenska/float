package float

import "fmt"

// Format converts the extended floating-point number f to a string,
// according to the format fmt. It rounds the result assuming that the
// original was obtained from a floating-point value of 80 bits.
//
// The format fmt is one of
// 'b' (-ddddp±ddd, a binary exponent),
// 'e' (-d.dddde±dd, a decimal exponent),
// 'E' (-d.ddddE±dd, a decimal exponent),
// 'f' (-ddd.dddd, no exponent),
//
// The precision prec controls the number of digits (excluding the exponent)
// printed by the 'e', 'E', 'f' formats.
// For 'e', 'E', 'f' it is the number of digits after the decimal point.
func (a X80) Format(fmt byte, prec int) string {
	return string(a.genericFtoa(make([]byte, 0, max(int(prec)+4, 24)), fmt, prec))
}

// Append appends the string form of the floating-point number f,
// as generated by FormatFloat, to dst and returns the extended buffer.
func (a X80) Append(dst []byte, fmt byte, prec int) []byte {
	return a.genericFtoa(dst, fmt, prec)
}

func (a X80) genericFtoa(dst []byte, fmt byte, prec int) []byte {
	neg := a.sign()
	exp := a.exp()
	mant := a.frac()

	switch exp {
	case 0x7fff:
		// Inf, NaN
		var s string
		switch {
		case mant != 0:
			s = "NaN"
		case neg:
			s = "-Inf"
		default:
			s = "+Inf"
		}
		return append(dst, s...)

	case 0:
		// denormalized
		exp++

	default:
		// add implicit top bit
		mant |= uint64(1) << 63
	}
	exp -= 0x3fff // -bias

	// Pick off easy binary, hex formats.
	if fmt == 'b' {
		return fmtB(dst, neg, mant, exp)
	}

	return bigFtoa(dst, prec, fmt, neg, mant, exp)
}

// bigFtoa uses multiprecision computations to format a float.
func bigFtoa(dst []byte, prec int, fmt byte, neg bool, mant uint64, exp int) []byte {
	d := new(decimal)
	d.Assign(mant)
	d.Shift(exp - 63)
	var digs decimalSlice

	// Round appropriately.
	switch fmt {
	case 'e', 'E':
		d.Round(prec + 1)
	case 'f':
		d.Round(d.dp + prec)
	}
	digs = decimalSlice{d: d.d[:], nd: d.nd, dp: d.dp}

	return formatDigits(dst, neg, digs, prec, fmt)
}

func formatDigits(dst []byte, neg bool, digs decimalSlice, prec int, fmt byte) []byte {
	switch fmt {
	case 'e', 'E':
		return fmtE(dst, neg, digs, prec, fmt)
	case 'f':
		return fmtF(dst, neg, digs, prec)
	}

	// unknown format
	return append(dst, '%', fmt)
}

type decimalSlice struct {
	d      []byte
	nd, dp int
	neg    bool
}

// %e: -d.ddddde±dd
func fmtE(dst []byte, neg bool, d decimalSlice, prec int, fmt byte) []byte {
	// sign
	if neg {
		dst = append(dst, '-')
	}

	// first digit
	ch := byte('0')
	if d.nd != 0 {
		ch = d.d[0]
	}
	dst = append(dst, ch)

	// .moredigits
	if prec > 0 {
		dst = append(dst, '.')
		i := 1
		m := min(d.nd, prec+1)
		if i < m {
			dst = append(dst, d.d[i:m]...)
			i = m
		}
		for ; i <= prec; i++ {
			dst = append(dst, '0')
		}
	}

	// e±
	dst = append(dst, fmt)
	exp := d.dp - 1
	if d.nd == 0 { // special case: 0 has exponent 0
		exp = 0
	}
	if exp < 0 {
		ch = '-'
		exp = -exp
	} else {
		ch = '+'
	}
	dst = append(dst, ch)

	// dd or ddd
	switch {
	case exp < 10:
		dst = append(dst, '0', byte(exp)+'0')
	case exp < 100:
		dst = append(dst, byte(exp/10)+'0', byte(exp%10)+'0')
	default:
		dst = append(dst, byte(exp/100)+'0', byte(exp/10)%10+'0', byte(exp%10)+'0')
	}

	return dst
}

// %f: -ddddddd.ddddd
func fmtF(dst []byte, neg bool, d decimalSlice, prec int) []byte {
	// sign
	if neg {
		dst = append(dst, '-')
	}

	// integer, padded with zeros as needed.
	if d.dp > 0 {
		m := min(d.nd, d.dp)
		dst = append(dst, d.d[:m]...)
		for ; m < d.dp; m++ {
			dst = append(dst, '0')
		}
	} else {
		dst = append(dst, '0')
	}

	// fraction
	if prec > 0 {
		dst = append(dst, '.')
		for i := 0; i < prec; i++ {
			ch := byte('0')
			if j := d.dp + i; 0 <= j && j < d.nd {
				ch = d.d[j]
			}
			dst = append(dst, ch)
		}
	}

	return dst
}

// %b: -ddddddddp±ddd
func fmtB(dst []byte, neg bool, mant uint64, exp int) []byte {
	// sign
	if neg {
		dst = append(dst, '-')
	}

	// mantissa
	dst, _ = formatBits(dst, mant, 10, false, true)

	// p
	dst = append(dst, 'p')

	// ±exponent
	exp -= 63
	if exp >= 0 {
		dst = append(dst, '+')
	}
	dst, _ = formatBits(dst, uint64(exp), 10, exp < 0, true)

	return dst
}

// Internal returns the internal represantion of the 80bit float value in hex format.
func (a X80) Internal() string {
	return fmt.Sprintf("%04X%016X", a.high, a.low)
}

func (a X80) String() string {
	return a.Format('f', 30)
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
